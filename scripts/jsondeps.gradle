
// TODO: finish
// You can manually debug this by running `gradle -I etc.`

// A gradle init script to add a `jsonDeps` task.
// This task outputs project dependency trees as JSON.
//
// The resulting JSON output is a map of configuration names to an array of
// top-level dependencies.
//
// Dependencies have a "type", either "project" or "package"
//
// "project" dependencies look like: `{ "type": "project", "name": ":project-name" }`
// "package" dependencies look like: `{ "type": "package", "name": "group:module", "version": "1.0", "dependencies": [] }`
//
// Semantically:
//
// type ConfigurationName = Text
// type Name = Text
// type Version = Text
//
// type Output = Map ConfigurationName [Dependency]
//
// data Dependency =
//     Project Name -- first-party (sub)projects
//   | Package Name Version [Dependency]

allprojects {
    task jsonDeps {
        doLast {
            def depToJSON
            depToJSON = { resolvedDep ->
                println "RESOLVED DEP"
                println resolvedDep
                println "MODULE ARTIFACTS"
                println resolvedDep.moduleArtifacts
                println resolvedDep.moduleArtifacts.size()
                def artifact = resolvedDep.moduleArtifacts.iterator().next() // moduleArtifacts never returns null; can it return empty set? it seems to only return a single module or project
                println "ARTIFACT"
                println artifact
                def id = artifact.id.componentIdentifier
                def json = "{"
                if (id instanceof ProjectComponentIdentifier) {
                    // Minor problem here: we don't get the specific configuration used for the subproject.
                    // The default is the configuration named "default"
                    json += "\"type\":\"project\",\"name\":\"${id.projectPath}\""
                } else if (id instanceof ModuleComponentIdentifier) {
                    json += "\"type\":\"package\",\"name\":\"${id.group}:${id.module}\",\"version\":\"${id.version}\","
                    def childResults = []
                    if (!resolvedDep.children.isEmpty()) {
                        resolvedDep.children.each { childResolvedDep ->
                            if (childResolvedDep.moduleArtifacts.size() > 0) {
                                def result = depToJSON childResolvedDep
                                childResults << result
                            } else {
                                println "DEP WITH NO MODULES"
                                println childResolvedDep
                            }
                        }
                    }
                    json += "\"dependencies\":["
                    json += childResults.join(",")
                    json += "]"
                } else {
                    return null; // FUTURE: binary dependencies in the filetree
                }

                json += "}"

                return json
            }

            def configToKeyValue = { config ->
                def jsonDeps = []
                println "TRYING CONFIG"
                println config
                // https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/Configuration.html
                config.resolvedConfiguration.firstLevelModuleDependencies.each { dep ->
                    println "DEP"
                    println dep
                    def result = depToJSON dep
                    if (result != null) {
                        jsonDeps << result
                    }
                }
                def combined = jsonDeps.join(",")
                return "\"${config.name}\":[${combined}]"
            }

            def projectToJSON = { project ->
                def jsonConfigs = []
                project.configurations.each { config ->
                    println "CONFIG"
                    println config
                    try {
                        def result = configToKeyValue config
                        // println "RESULT"
                        // println result
                        jsonConfigs << result
                    } catch (IllegalStateException e) {
                        if (e.getMessage().contains("canBeResolved=false")) {
                            println "CANNOT BE RESOLVED"
                        } else {
                            throw e
                        }
                    } catch (Exception ignored) {
                        println "EXCEPTION"
                        println ignored
                        // ignored.printStackTrace()
                    }
                }
                // println "JSON CONFIGS"
                // println jsonConfigs
                def combined = jsonConfigs.join(",")
                return "{${combined}}"
            }

            def result = projectToJSON project
            println "DONE"
            println "JSONDEPS_${project.path}_${result}"
        }
    }
}
